\documentclass[fleqn]{article}

\usepackage{graphicx, fullpage, amssymb, amsmath}
\usepackage{placeins}

\begin{document}

\centerline{\sc \large EECS 405 - Project Report}
\vspace{.5pc}
\centerline{\sc Nathan McKinley (ndm25) and Umang Banugaria (uxb3)}
\centerline{\it April 22, 2013}
\vspace{2pc}

\section{Abstract}
We sought to examine the properties of B-trees and B+-trees under the no-coalescing model which is usually chosen in industry.  We found that under some insert/delete workloads for uniformly random key selection, the no-coalescing model performs better in time.  In all cases, the no-coalescing model performs worse in space: its use of the allocated space sometimes drops below the 50% minimum which is enforced when coalescing is on.

We also found that the tree height is greater when coalescing is turned on; although we did not test time for queries in out experiments, this indicates that performing sufficiently many queries will cause coalescing to be preferable.

\section{Introduction}
B+-tree-based indices are often used in database systems in order to improve query time.  Maintaining these indices is a time cost which is balanced by the benefit of having a smaller tree and using the space which you have allocated more efficiently.  Some database systems used in industry choose to turn off this maintenance, or to perform it only occasionally when the database is under very light load.  When the maintenance is turned off, the B-tree is not required to maintain its constraint that all nodes be at least 50% full.  The index will split nodes as usual when they become overfull, but never merge them back together, instead deleting them when they become completely empty.  Noticing an underflow will not cause a merge-and-split or even a merge.

We wanted to test what conditions would lead to this being a beneficial choice, so we implemented a B-tree and B+-tree in python with a convenient command-line interface.  We implemented these trees capable of taking in key size, data record size, index pointer size, data pointer size, and block size.  These trees also take in a boolean parameter for whether or not they should coalesce when they detect an underflow.  See section 3 for the implementation details.

We also implemented a visualizer GUI which allows control over the simulation.  See section 4 for the implementation details of the visualizer.

\section{Tree Implementation}

For this project, we chose to implement two different tree structures: B trees and B+ trees.  Both tree structures are a dense index and reside in main memory.  They can each take in various parameters to allow for different order trees.  They also provide a set of functions to perform operations on the tree and gain information about the tree.  Since the purpose of this project is to explore the change in performance as the various parameters of the trees are modified, the customizable parameters are essential.  The parameters that can be set when creating a tree are:

\begin{enumerate}
\item
the key size
\item
the size of a data record
\item
the size of a data record pointer
\item
the size of a block pointer
\item
the block size
\item
whether the trees will perform coalescing when underflows occur.
\end{enumerate}
Once the trees are created, the following three operations that can be performed on the trees are:
\begin{enumerate}
\item
insert(key):  inserts the key into the tree index
\item
delete(key): deletes the key from the tree index if it is in the index.  if the key is not in the index, nothing will be done
\item
lookup(key): returns the level of the tree where there is a data pointer with a matching key.  The the case of B+ trees, this will always be the height of the tree but in B trees, it can be anywhere between 1(root) and the height.  If the key does not exist in the tree, -1 is returned
\end{enumerate}

To learn more about the structure of the tree that is created after insertions and deletions, various functions provided by both tree implementations can be used.  The following five functions are available:
\begin{enumerate}
\item
height():  returns the height of the tree
\item
numIndexBlocks(): returns the number of internal and leaf nodes being used within the tree index
\item
numDataBlocks(): returns the minimum number of blocks that would be needed to store all of the data.  this is based on the block size and data record size
\item
numElements(): returns the number of data record pointers stored in the tree
\item
storageUtil(): returns the fraction of the space used in the internal and leaf blocks.  this is computed by taking the space required by the keys, data record pointers, and block pointers and dividing it by the total space allocated to the blocks for the internal and leaf nodes.
\end{enumerate}
Since these trees were implemented to be part of a simulation, they do not actually store any data records, only the keys are stored.  To determine when a split or merge is needed, we compute the order of internal and leaf nodes based on the parameters that were set when the tree was created.  This allows us to vary the parameters to form different order trees independently of how the pointer and key data is stored in memory.

\section{GUI}

The GUI was implemented in TKinter, the standard python GUI library.  It has three menus available.  The first is for control of the window, which allows printing to postscript (the best way to view trees with gigantic branching factors), and exiting.  The second is for control of the display, which allows resizing of the text in the window.  The third is for control of the simulation, and allows for entering of new parameters to the simulation, as well as re-running the simulation.\\

The GUI is inherited primarily from the NLTK toolkit's TKinter tree-drawing method.  We convert our B-plus trees into NLTK-style trees, where each node represents a B-tree node and has as its children, in order, the children of the B-plus tree.  Then, we tell the NLTK-drawing toolkit to draw the tree in the canvas which is in the center of the GUI.

Included here are screenshots of the GUI in all modes of operation:



\section{Simulation}


\section{Experiments}

\section{Conclusion}

\end{document}